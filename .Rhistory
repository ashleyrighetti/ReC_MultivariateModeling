#Index of moderated moderation
MMimm <- digits(cParamEsts$est[19], 3) #B weight for the c3' path
MMimm
MMimm_SE <- digits(cParamEsts$se[19], 3)#SE for the c3' path
MMimm_SE
MMimm_p <- digits(cParamEsts$pvalue[19], 3)#p value for the c3' path
MMimm_p
MMtotL <-  digits(cParamEsts$est[26], 3)#B weight for the total effect, 1 SD below mean
MMtotL
MMtot_pL <- digits(cParamEsts$pvalue[26], 3)#p value for the total effect, 1 SD below mean
MMtot_pL
MMtot_CIloL <- digits(cParamEsts$ci.lower[26], 3) #lower confidence interval, 1 SD below mean
MMtot_CIloL
MMtot_CIhiL <- digits(cParamEsts$ci.upper[26], 3) #upper confidence interval, 1 SD below mean
MMtot_CIhiL
MMtotM <-  digits(cParamEsts$est[27], 3)#B weight for the total effect, at mean
MMtotM
MMtot_pM <- digits(cParamEsts$pvalue[27], 3)#p value for the total effect, at mean
MMtot_pM
MMtot_CIloM <- digits(cParamEsts$ci.lower[27], 3) #lower confidence interval, at mean
MMtot_CIloM
MMtot_CIhiM <- digits(cParamEsts$ci.upper[27], 3) #upper confidence interval, at mean
MMtot_CIhiM
MMtotH <-  digits(cParamEsts$est[28], 3)#B weight for the total effect, 1SD above mean
MMtotH
MMtot_pH <- digits(cParamEsts$pvalue[28], 3)#p value for the total effect, 1SD above mean
MMtot_pH
MMtot_CIloH <- digits(cParamEsts$ci.lower[28], 3) #lower confidence interval, 1SD above mean
MMtot_CIloH
MMtot_CIhiH <- digits(cParamEsts$ci.upper[28], 3) #upper confidence interval, 1SD above mean
MMtot_CIhiH
MMtotL <-  digits(cParamEsts$est[26], 3)#B weight for the total effect, 1 SD below mean
MMtotL
MMtotL_se <- digits(cParamEsts$se[26], 3)#SE weight for the total effect, 1 SD below mean
MMtotL_se
MMtot_pL <- digits(cParamEsts$pvalue[26], 3)#p value for the total effect, 1 SD below mean
MMtot_pL
MMtot_CIloL <- digits(cParamEsts$ci.lower[26], 3) #lower confidence interval, 1 SD below mean
MMtot_CIloL
MMtot_CIhiL <- digits(cParamEsts$ci.upper[26], 3) #upper confidence interval, 1 SD below mean
MMtot_CIhiL
MMtotM <-  digits(cParamEsts$est[27], 3)#B weight for the total effect, at mean
MMtotM
MMtotM_se <- digits(cParamEsts$se[27], 3)#SE weight for the total effect, at mean
MMtotM_se
MMtot_pM <- digits(cParamEsts$pvalue[27], 3)#p value for the total effect, at mean
MMtot_pM
MMtot_CIloM <- digits(cParamEsts$ci.lower[27], 3) #lower confidence interval, at mean
MMtot_CIloM
MMtot_CIhiM <- digits(cParamEsts$ci.upper[27], 3) #upper confidence interval, at mean
MMtot_CIhiM
MMtotH <-  digits(cParamEsts$est[28], 3)#B weight for the total effect, 1SD above mean
MMtotH
MMtotH_se <- digits(cParamEsts$se[28], 3)#SE weight for the total effect, 1SD above mean
MMtotH_se
MMtot_pH <- digits(cParamEsts$pvalue[28], 3)#p value for the total effect, 1SD above mean
MMtot_pH
MMtot_CIloH <- digits(cParamEsts$ci.lower[28], 3) #lower confidence interval, 1SD above mean
MMtot_CIloH
MMtot_CIhiH <- digits(cParamEsts$ci.upper[28], 3) #upper confidence interval, 1SD above mean
MMtot_CIhiH
MMdirL <-  digits(cParamEsts$est[23], 3)#B weight for the direct effect, 1 SD below mean
MMdirL
MMdir_seL <-  digits(cParamEsts$est[23], 3)#SE weight for the direct effect, 1 SD below mean
MMdir_seL
MMdir_pL <- digits(cParamEsts$pvalue[23], 3)#p value for the direct effect, 1 SD below mean
MMdir_pL
MMdir_CIloL <- digits(cParamEsts$ci.lower[23], 3) #lower confidence interval, 1 SD below mean
MMdir_CIloL
MMdir_CIhiL <- digits(cParamEsts$ci.upper[23], 3) #upper confidence interval, 1 SD below mean
MMdir_CIhiL
MMdirM <-  digits(cParamEsts$est[24], 3)#B weight for the direct effect, at mean
MMdirM
MMdir_seM <-  digits(cParamEsts$est[24], 3)#SE weight for the direct effect, at mean
MMdir_seM
MMdir_pM <- digits(cParamEsts$pvalue[24], 3)#p value for the direct effect, at mean
MMdir_pM
MMdir_CIloM <- digits(cParamEsts$ci.lower[24], 3) #lower confidence interval, at mean
MMdir_CIloM
MMdir_CIhiM <- digits(cParamEsts$ci.upper[24], 3) #upper confidence interval, at mean
MMdir_CIhiM
MMdirH <-  digits(cParamEsts$est[25], 3)#B weight for the direct effect, 1SD above mean
MMdirH
MMdir_seH <-  digits(cParamEsts$est[25], 3)#SE weight for the direct effect, 1SD above mean
MMdir_seH
MMdir_pH <- digits(cParamEsts$pvalue[25], 3)#p value for the direct effect, 1SD above mean
MMdir_pH
MMdir_CIloH <- digits(cParamEsts$ci.lower[25], 3) #lower confidence interval, 1SD above mean
MMdir_CIloH
MMdir_CIhiH <- digits(cParamEsts$ci.upper[25], 3) #upper confidence interval, 1SD above mean
MMdir_CIhiH
MMdirL <-  digits(cParamEsts$est[23], 3)#B weight for the direct effect, 1 SD below mean
MMdirL
MMdir_seL <-  digits(cParamEsts$se[23], 3)#SE weight for the direct effect, 1 SD below mean
MMdir_seL
MMdir_pL <- digits(cParamEsts$pvalue[23], 3)#p value for the direct effect, 1 SD below mean
MMdir_pL
MMdir_CIloL <- digits(cParamEsts$ci.lower[23], 3) #lower confidence interval, 1 SD below mean
MMdir_CIloL
MMdir_CIhiL <- digits(cParamEsts$ci.upper[23], 3) #upper confidence interval, 1 SD below mean
MMdir_CIhiL
MMdirM <-  digits(cParamEsts$est[24], 3)#B weight for the direct effect, at mean
MMdirM
MMdir_seM <-  digits(cParamEsts$se[24], 3)#SE weight for the direct effect, at mean
MMdir_seM
MMdir_pM <- digits(cParamEsts$pvalue[24], 3)#p value for the direct effect, at mean
MMdir_pM
MMdir_CIloM <- digits(cParamEsts$ci.lower[24], 3) #lower confidence interval, at mean
MMdir_CIloM
MMdir_CIhiM <- digits(cParamEsts$ci.upper[24], 3) #upper confidence interval, at mean
MMdir_CIhiM
MMdirH <-  digits(cParamEsts$est[25], 3)#B weight for the direct effect, 1SD above mean
MMdirH
MMdir_seH <-  digits(cParamEsts$se[25], 3)#SE weight for the direct effect, 1SD above mean
MMdir_seH
MMdir_pH <- digits(cParamEsts$pvalue[25], 3)#p value for the direct effect, 1SD above mean
MMdir_pH
MMdir_CIloH <- digits(cParamEsts$ci.lower[25], 3) #lower confidence interval, 1SD above mean
MMdir_CIloH
MMdir_CIhiH <- digits(cParamEsts$ci.upper[25], 3) #upper confidence interval, 1SD above mean
MMdir_CIhiH
MMindL <- digits(cParamEsts$est[20], 3) #estimate for the indirect effect, 1 SD below mean
MMindL
MMind_seL <-  digits(cParamEsts$se[20], 3)#SE weight for the inddirect effect, 1 SD below mean
MMind_seL
MMind_pL <- digits(cParamEsts$pvalue[20], 3) #p value for the indirect effect, 1 SD below mean
MMind_pL
MMind_CIloL <- digits(cParamEsts$ci.lower[20], 3) #lower confidence interval, 1 SD below mean
MMind_CIloL
MMind_CIhiL <- digits(MMim_ParamEsts$ci.upper[20], 3) #upper confidence interval, 1 SD below mean
MMindL <- digits(cParamEsts$est[20], 3) #estimate for the indirect effect, 1 SD below mean
MMindL
MMind_seL <-  digits(cParamEsts$se[20], 3)#SE weight for the inddirect effect, 1 SD below mean
MMind_seL
MMind_pL <- digits(cParamEsts$pvalue[20], 3) #p value for the indirect effect, 1 SD below mean
MMind_pL
MMind_CIloL <- digits(cParamEsts$ci.lower[20], 3) #lower confidence interval, 1 SD below mean
MMind_CIloL
MMind_CIhiL <- digits(cParamEsts$ci.upper[20], 3) #upper confidence interval, 1 SD below mean
MMind_CIhiL
MMindM <- digits(cParamEsts$est[21], 3) #estimate for the indirect effect, at mean
MMindM
MMind_seM <-  digits(cParamEsts$se[21], 3)#SE weight for the inddirect effect, at mean
MMind_seM
MMind_pM <- digits(cParamEsts$pvalue[21], 3) #p value for the indirect effect, at mean
MMind_pM
MMind_CIloM <- digits(cParamEsts$ci.lower[21], 3) #lower confidence interval, at mean
MMind_CIloM
MMind_CIhiM <- digits(cParamEsts$ci.upper[21], 3) #upper confidence interval, at mean
MMind_CIhiM
MMindH <- digits(cParamEsts$est[22], 3) #estimate for the indirect effect, 1SD above mean
MMindH
MMind_seH <-  digits(cParamEsts$se[22], 3)#SE weight for the inddirect effect, 1SD above mean
MMind_seH
MMind_pH <- digits(cParamEsts$pvalue[22], 3) #p value for the indirect effect, 1SD above mean
MMind_pH
MMind_CIloH <- digits(cParamEsts$ci.lower[22], 3) #lower confidence interval, 1SD above mean
MMind_CIloH
MMind_CIhiH <- digits(cParamEsts$ci.upper[22], 3) #upper confidence interval, 1SD above mean
MMind_CIhiH
View(cFITsum)
set.seed(190505)
Combined <- '
#equations
DisEngmt ~ a1*GRMS + a2*GRIcntlty + a3*GRMS:GRIcntlty
MntlHlth ~ c_p1*GRMS + c_p2*GRIcntlty + c_p3*GRMS:GRIcntlty + b*DisEngmt
#intercepts
DisEngmt ~ DisEngmt.mean*1
MntlHlth ~ MntlHlth.mean*1
#means, variances of W for simple slopes
GRIcntlty ~ GRIcntlty.mean*1
GRIcntlty ~~ GRIcntlty.var*GRIcntlty
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a3*b
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a1*b + imm*(GRIcntlty.mean - sqrt(GRIcntlty.var))
indirect.mean := a1*b + imm*(GRIcntlty.mean)
indirect.SDabove := a1*b + imm*(GRIcntlty.mean + sqrt(GRIcntlty.var))
#direct effect is also moderated so calculate with c_p1 + c_p3
direct.SDbelow := c_p1 + c_p3*(GRIcntlty.mean - sqrt(GRIcntlty.var))
direct.Smean := c_p1 + c_p3*(GRIcntlty.mean)
direct.SDabove := c_p1 + c_p3*(GRIcntlty.mean + sqrt(GRIcntlty.var))
#total effect
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.mean := direct.Smean + indirect.mean
total.SDabove := direct.SDabove + indirect.SDabove
'
Combined_fit <- sem(Combined, data = Lewis_df, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
cFITsum <- summary(Combined_fit, standardized = TRUE, rsq=T, ci=TRUE)
cParamEsts <- parameterEstimates(Combined_fit, boot.ci.type = "bca.simple", standardized=TRUE)
View(Combined_fit)
options(scipen=999)#eliminates scientific notation
#Entering the intercorrelations, means, and standard deviations from the journal article
LEWmu <- c(1.99, 2.82, 2.48, 2.32, 1.75, 5.71, 21.37, 21.07)
LEWsd <- c(.90, .70, .81, .61, .53, 1.03, 3.83, 4.66)
LEWr_mat <- matrix (c(1, .20, .28, .30, .41, .19, -.32, -.18,
.20, 1, .49, .57, .22, .13, -.06, -.13,
.28, .49, 1, .46, .26, .38, -.18,-.08,
.30, .57, .46,  1, .37, .08, -.14, -.06,
.41, .22, .26, .37, 1, .05, -.54, -.28,
.19, .13, .38, .08, .05, 1, -.10, .14,
-.32, -.06, -.18, -.14, -.54, -.10, 1, .47,
-.18, -.13, -.08, -.06, -.28, .14, .47, 1), ncol = 8)
#Creating a covariance matrix
LEWcov_mat <- LEWsd %*% t(LEWsd) * LEWr_mat
LEWcov_mat
#Set random seed so that the following matrix always gets the same results.
set.seed(210403)
library(MASS)
Lewis_df <- mvrnorm(n = 212, mu=LEWmu, Sigma = LEWcov_mat, empirical = TRUE)
colMeans(Lewis_df)
#Checking our work against the original correlation matrix
cor(Lewis_df)
as.data.frame(Lewis_df, row.names = NULL, optional = FALSE, make.names = TRUE)
library(tidyverse)
Lewis_df <- Lewis_df%>%
as.data.frame %>%
rename(GRMS = V1, Sprtlty = V2, SocSup = V3, Engmgt = V4, DisEngmt = V5, GRIcntlty = V6, MntlHlth = V7, PhysHlth = V8)
head(Lewis_df)
library(psych)
psych::describe(Lewis_df)
library(jtools) #the summ function creates a terrific regression table
library(interactions)
library(ggplot2)
Mod_a_path <- lm(DisEngmt~GRMS*GRIcntlty, data=Lewis_df)
summ(Mod_a_path, digits = 3)
interact_plot(Mod_a_path, pred = GRMS, modx = GRIcntlty)
interact_plot(Mod_a_path, pred = GRIcntlty, modx = GRMS)
sim_slopes(Mod_a_path, pred = GRMS, modx = GRIcntlty)
#sim_slopes(Mod_a_path, pred=GRIcntlty, modx = GRMS) #sometimes I like to look at it in reverse -- like in the plots
Mod_c_path <- lm(MntlHlth~GRMS*GRIcntlty, data=Lewis_df)
summ(Mod_c_path, digits = 3)
interact_plot(Mod_c_path, pred = GRMS, modx = GRIcntlty)
interact_plot(Mod_c_path, pred = GRIcntlty, modx = GRMS)
sim_slopes(Mod_c_path, pred = GRMS, modx = GRIcntlty)
#sim_slopes(Mod_c_path, pred=GRIcntlty, modx = GRMS) #sometimes I like to look at it in reverse -- like in the plots
library(lavaan)
set.seed(210421) #reset in case you choose to separate these sections
LMedModel <- '
MntlHlth ~ b*DisEngmt + c_p*GRMS
DisEngmt ~a*GRMS
#intercepts
DisEngmt ~ DisEngmt.mean*1
MntlHlth ~ MntlHlth.mean*1
indirect :=  a*b
direct  := c_p
total_c  := c_p + (a*b)
'
LMed_fit <- sem(LMedModel, data = Lewis_df, se="bootstrap", missing = 'fiml')
LMed_Sum <-  summary(LMed_fit, standardized=T, rsq=T, ci=TRUE)
LMed_ParEsts<- parameterEstimates(LMed_fit, boot.ci.type = "bca.simple", standardized=TRUE)
LMed_Sum
LMed_ParEsts
set.seed(210421)
library(semPlot)
semPaths(LMed_fit, #must identiy the model you want to map
what = "est", #"est" plots the estimates, but keeps it greyscale with no fading
#whatLabels = "stand", #"stand" changes to standardized values
layout = 'tree', rotation = 2, #together, puts predictors on left, IVs on right
#layout = 'circle',
edge.label.cex = 1.00, #font size of parameter values
#edge.color = "black", #overwrites the green/black coloring
sizeMan=10, #size of squares/observed/"manifest" variables
fade=FALSE, #if TRUE, there lines are faded such that weaker lines correspond with lower values -- a cool effect, but tough for journals
esize=2,
asize=3,
#label.prop = .5,
label.font = 2.5, #controls size (I think) of font for labels
label.scale = TRUE, #if false, the labels will not scale to fit inside the nodes
nDigits = 3, #decimal places (default is 2)
residuals = FALSE,#excludes residuals (and variances) from the path diagram
nCharNodes = 0, #specifies how many characters to abbreviate variable lables; default is 3.  If 0, uses your entire variable label and adjusts fontsize (which could be a downside)
intercepts = FALSE, #gets rid of those annoying triangles (intercepts) in the path diagram)
)
title("Disengagement Coping as Mediator between GRMS and Mental Health")
set.seed(190505)
Combined <- '
#equations
DisEngmt ~ a1*GRMS + a2*GRIcntlty + a3*GRMS:GRIcntlty
MntlHlth ~ c_p1*GRMS + c_p2*GRIcntlty + c_p3*GRMS:GRIcntlty + b*DisEngmt
#intercepts
DisEngmt ~ DisEngmt.mean*1
MntlHlth ~ MntlHlth.mean*1
#means, variances of W for simple slopes
GRIcntlty ~ GRIcntlty.mean*1
GRIcntlty ~~ GRIcntlty.var*GRIcntlty
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a3*b
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a1*b + imm*(GRIcntlty.mean - sqrt(GRIcntlty.var))
indirect.mean := a1*b + imm*(GRIcntlty.mean)
indirect.SDabove := a1*b + imm*(GRIcntlty.mean + sqrt(GRIcntlty.var))
#direct effect is also moderated so calculate with c_p1 + c_p3
direct.SDbelow := c_p1 + c_p3*(GRIcntlty.mean - sqrt(GRIcntlty.var))
direct.Smean := c_p1 + c_p3*(GRIcntlty.mean)
direct.SDabove := c_p1 + c_p3*(GRIcntlty.mean + sqrt(GRIcntlty.var))
#total effect
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.mean := direct.Smean + indirect.mean
total.SDabove := direct.SDabove + indirect.SDabove
'
Combined_fit <- sem(Combined, data = Lewis_df, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
cFITsum <- summary(Combined_fit, standardized = TRUE, rsq=T, ci=TRUE)
cParamEsts <- parameterEstimates(Combined_fit, boot.ci.type = "bca.simple", standardized=TRUE)
# Proportion of variance accounted for
MM_Rsq_Y <- percent(cFITsum$PE$est[35])
library(formattable) #to use the digits function
MM_Rsq_Y <- percent(cFITsum$PE$est[35])
MM_Rsq_Y
MM_Rsq_M <- percent(cFITsum$PE$est[36])
MM_Rsq_M
# Proportion of variance accounted for
MM_Rsq_Y <- percent(cFITsum$PE$est[30])
MM_Rsq_Y
MM_Rsq_M <- percent(cFITsum$PE$est[31])
MM_Rsq_M
MM_Rsq_Y <- percent(cFITsum$PE$est[29])
MM_Rsq_Y
MM_Rsq_M <- percent(cFITsum$PE$est[30])
MM_Rsq_M
# Proportion of variance accounted for
MM_Rsq_Y <- percent(cFITsum$PE$est[30])
MM_Rsq_Y
MM_Rsq_M <- percent(cFITsum$PE$est[29])
MM_Rsq_M
MMimm_CIloL <- digits(cParamEsts$ci.lower[19], 3) #lower confidence interval, 1 SD below mean
MMimm_CIloL
MMimm_CIhiL <- digits(cParamEsts$ci.upper[19], 3) #upper confidence interval, 1 SD below mean
MMimm_CIhiL
citr:::insert_citation()
citr:::insert_citation()
citr:::insert_citation()
citr:::insert_citation()
#Entering the intercorrelations, means, and standard deviations from the journal article
LEWmu <- c(1.99, 2.82, 2.48, 2.32, 1.75, 5.71, 21.37, 21.07)
LEWsd <- c(.90, .70, .81, .61, .53, 1.03, 3.83, 4.66)
LEWr_mat <- matrix (c(1, .20, .28, .30, .41, .19, -.32, -.18,
.20, 1, .49, .57, .22, .13, -.06, -.13,
.28, .49, 1, .46, .26, .38, -.18,-.08,
.30, .57, .46,  1, .37, .08, -.14, -.06,
.41, .22, .26, .37, 1, .05, -.54, -.28,
.19, .13, .38, .08, .05, 1, -.10, .14,
-.32, -.06, -.18, -.14, -.54, -.10, 1, .47,
-.18, -.13, -.08, -.06, -.28, .14, .47, 1), ncol = 8)
#Creating a covariance matrix
LEWcov_mat <- LEWsd %*% t(LEWsd) * LEWr_mat
LEWcov_mat
#Set random seed so that the following matrix always gets the same results.
set.seed(210403)
library(MASS)
Lewis_df <- mvrnorm(n = 212, mu=LEWmu, Sigma = LEWcov_mat, empirical = TRUE)
colMeans(Lewis_df)
#Checking our work against the original correlation matrix
cor(Lewis_df)
as.data.frame(Lewis_df, row.names = NULL, optional = FALSE, make.names = TRUE)
library(tidyverse)
Lewis_df <- Lewis_df%>%
as.data.frame %>%
rename(GRMS = V1, Sprtlty = V2, SocSup = V3, Engmgt = V4, DisEngmt = V5, GRIcntlty = V6, MntlHlth = V7, PhysHlth = V8)
library(tidyverse)
ModMedDemo_df <- rename(Lewis_df, X = GRMS, Y = MntlHlth, W = GRIcntrlty, M = DisEngmt )
library(tidyverse)
ModMedDemo_df <- rename(Lewis_df, X = GRMS, Y = MntlHlth, W = GRIcntlty, M = DisEngmt )
set.seed(190505)
library(lavaan)
library(lavaan)
set.seed(190505)
ModMedDemo <- '
#equations
M ~ a1*X + a2*W + a3*X:W
Y ~ c_p1*X + c_p2*W + c_p3*X:W + b*M
#intercepts
M ~ M.mean*1
Y ~ Y.mean*1
#means, variances of W for simple slopes
W ~ W.mean*1
W ~~ W.var*GRIcntlty
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a3*b
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a1*b + imm*(W.mean - sqrt(W.var))
indirect.mean := a1*b + imm*(W.mean)
indirect.SDabove := a1*b + imm*(W.mean + sqrt(W.var))
#direct effect is also moderated so calculate with c_p1 + c_p3
direct.SDbelow := c_p1 + c_p3*(W.mean - sqrt(W.var))
direct.Smean := c_p1 + c_p3*(W.mean)
direct.SDabove := c_p1 + c_p3*(W.mean + sqrt(W.var))
#total effect
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.mean := direct.Smean + indirect.mean
total.SDabove := direct.SDabove + indirect.SDabove
'
ModMedDemo_fit <- sem(ModMedDemo, data = Lewis_df, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
library(lavaan)
set.seed(190505)
ModMedDemo <- '
#equations
M ~ a1*X + a2*W + a3*X:W
Y ~ c_p1*X + c_p2*W + c_p3*X:W + b*M
#intercepts
M ~ M.mean*1
Y ~ Y.mean*1
#means, variances of W for simple slopes
W ~ W.mean*1
W ~~ W.var*GRIcntlty
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a3*b
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a1*b + imm*(W.mean - sqrt(W.var))
indirect.mean := a1*b + imm*(W.mean)
indirect.SDabove := a1*b + imm*(W.mean + sqrt(W.var))
#direct effect is also moderated so calculate with c_p1 + c_p3
direct.SDbelow := c_p1 + c_p3*(W.mean - sqrt(W.var))
direct.Smean := c_p1 + c_p3*(W.mean)
direct.SDabove := c_p1 + c_p3*(W.mean + sqrt(W.var))
#total effect
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.mean := direct.Smean + indirect.mean
total.SDabove := direct.SDabove + indirect.SDabove
'
ModMedDemo_fit <- sem(ModMedDemo, data = ModMedDemo_df, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
library(lavaan)
set.seed(190505)
ModMedDemo <- '
#equations
M ~ a1*X + a2*W + a3*X:W
Y ~ c_p1*X + c_p2*W + c_p3*X:W + b*M
#intercepts
M ~ M.mean*1
Y ~ Y.mean*1
#means, variances of W for simple slopes
W ~ W.mean*1
W ~~ W.var*W
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a3*b
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a1*b + imm*(W.mean - sqrt(W.var))
indirect.mean := a1*b + imm*(W.mean)
indirect.SDabove := a1*b + imm*(W.mean + sqrt(W.var))
#direct effect is also moderated so calculate with c_p1 + c_p3
direct.SDbelow := c_p1 + c_p3*(W.mean - sqrt(W.var))
direct.Smean := c_p1 + c_p3*(W.mean)
direct.SDabove := c_p1 + c_p3*(W.mean + sqrt(W.var))
#total effect
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.mean := direct.Smean + indirect.mean
total.SDabove := direct.SDabove + indirect.SDabove
'
ModMedDemo_fit <- sem(ModMedDemo, data = ModMedDemo_df, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
ModMed_FitSum <- summary(ModMedDemo_fit, standardized = TRUE, rsq=T, ci=TRUE)
ModMed_ParamEsts <- parameterEstimates(ModMedDemo_fit, boot.ci.type = "bca.simple", standardized=TRUE)
set.seed(190505)
Combined <- '
#equations
DisEngmt ~ a1*GRMS + a2*GRIcntlty + a3*GRMS:GRIcntlty
MntlHlth ~ c_p1*GRMS + c_p2*GRIcntlty + c_p3*GRMS:GRIcntlty + b*DisEngmt
#intercepts
DisEngmt ~ DisEngmt.mean*1
MntlHlth ~ MntlHlth.mean*1
#means, variances of W for simple slopes
GRIcntlty ~ GRIcntlty.mean*1
GRIcntlty ~~ GRIcntlty.var*GRIcntlty
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a3*b
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a1*b + imm*(GRIcntlty.mean - sqrt(GRIcntlty.var))
indirect.mean := a1*b + imm*(GRIcntlty.mean)
indirect.SDabove := a1*b + imm*(GRIcntlty.mean + sqrt(GRIcntlty.var))
#direct effect is also moderated so calculate with c_p1 + c_p3
direct.SDbelow := c_p1 + c_p3*(GRIcntlty.mean - sqrt(GRIcntlty.var))
direct.Smean := c_p1 + c_p3*(GRIcntlty.mean)
direct.SDabove := c_p1 + c_p3*(GRIcntlty.mean + sqrt(GRIcntlty.var))
#total effect
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.mean := direct.Smean + indirect.mean
total.SDabove := direct.SDabove + indirect.SDabove
'
Combined_fit <- sem(Combined, data = Lewis_df, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
set.seed(190505)
Combined <- '
#equations
DisEngmt ~ a1*GRMS + a2*GRIcntlty + a3*GRMS:GRIcntlty
MntlHlth ~ c_p1*GRMS + c_p2*GRIcntlty + c_p3*GRMS:GRIcntlty + b*DisEngmt
#intercepts
DisEngmt ~ DisEngmt.mean*1
MntlHlth ~ MntlHlth.mean*1
#means, variances of W for simple slopes
GRIcntlty ~ GRIcntlty.mean*1
GRIcntlty ~~ GRIcntlty.var*GRIcntlty
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a3*b
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a1*b + imm*(GRIcntlty.mean - sqrt(GRIcntlty.var))
indirect.mean := a1*b + imm*(GRIcntlty.mean)
indirect.SDabove := a1*b + imm*(GRIcntlty.mean + sqrt(GRIcntlty.var))
#direct effect is also moderated so calculate with c_p1 + c_p3
direct.SDbelow := c_p1 + c_p3*(GRIcntlty.mean - sqrt(GRIcntlty.var))
direct.Smean := c_p1 + c_p3*(GRIcntlty.mean)
direct.SDabove := c_p1 + c_p3*(GRIcntlty.mean + sqrt(GRIcntlty.var))
#total effect
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.mean := direct.Smean + indirect.mean
total.SDabove := direct.SDabove + indirect.SDabove
'
Combined_fit <- sem(Combined, data = Lewis_df, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
